@using Microsoft.FSharp.Core
@using CardOverflow.Entity
@using CardOverflow.Pure
@using CardOverflow.Api
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Identity
@using CardOverflow.Sanitation
@using CardOverflow.Legacy
@using Domain
@inject DbExecutor DbExecutor
@inject Scheduler Scheduler
@inject TimeProvider TimeProvider
@inject IJSRuntime Js
@inject IToastService ToastService
@inject Dexie Dexie
@inject KeyValueStore KeyValueStore

@if (_instance == null) {
  <p><em>Loading...</em></p>
} else if (_instance.IsNone()) {
  <h1 class="text-center">No cards due!</h1>
  <h1 class="text-center">üëç</h1>
} else {
  // tabindex="0" makes keyboard shortcuts work
  <div class="study-content" tabindex="0" style="outline: none;" @onkeydown=@OnKeyDown @onclick=@FocusButton>
    <iframe sandbox="allow-scripts" class="study-iframe" srcdoc=@iframeSrcdoc></iframe>
    <div class="study-footer d-flex justify-content-between">
      <div>
        @if (isFront) {
          <button class="btn btn-study btn-primary" @onclick=@ShowBack @ref="ShowAnswerButton">Show answer</button>
        } else {
          <button class="btn btn-study btn-danger" @onclick=@(() => SaveScore(Score.Again))>
            <div>
              Again
            </div>
            <div>
              @AgainInterval
            </div>
          </button>
          <button class="btn btn-study btn-warning" @onclick=@(() => SaveScore(Score.Hard))>
            <div>
              Hard
            </div>
            <div>
              @HardInterval
            </div>
          </button>
          <button class="btn btn-study btn-primary" @onclick=@(() => SaveScore(Score.Good)) @ref="GoodButton">
            <div>
              Good
            </div>
            <div>
              @GoodInterval
            </div>
          </button>
          <button class="btn btn-study btn-success" @onclick=@(() => SaveScore(Score.Easy))>
            <div>
              Easy
            </div>
            <div>
              @EasyInterval
            </div>
          </button>
        }
      </div>
      <div>
        @transcript
        @if (isBlindMode) {
          <button class="btn btn-study btn-primary" @onclick=@DisableBlindMode>Disable blind mode</button>
        } else {
          <button class="btn btn-study btn-primary" @onclick=@EnableBlindMode>Enable blind mode</button>
        }
      </div>
    </div>
  </div>
}

@code {
  string iframeSrcdoc;
  bool isFront;
  [CascadingParameter] Task<Domain.Summary.User> UserTask { get; set; }
  private Domain.Summary.User _user = UserSummary.init;
  [Parameter] public Guid DeckId { get; set; }
  FSharpOption<Projection.ExampleInstance> _instance;
  Summary.Card _card;
  Summary.Stack _stack;
  Instant frontVisible;
  string transcript;
  bool isBlindMode;
  ElementReference GoodButton;
  ElementReference ShowAnswerButton;
  bool isRendered;
  string AgainInterval;
  string HardInterval;
  string GoodInterval;
  string EasyInterval;
  string _front;
  string _back;
  string _frontSynth;
  string _backSynth;
  CardSetting _cardSetting;

  private async Task loadCards() {
    var x = await Dexie.GetNextQuizCard();
    if (x.IsSome()) {
      _stack = x.Value.Item1;
      _card = x.Value.Item2;
      var instance = await KeyValueStore.GetExampleInstance(_stack.ExampleRevisionId).ToTask();
      (_front, _back, _frontSynth, _backSynth) = instance.FrontBackFrontSynthBackSynth(_card.Pointer);
      _instance = FSharpOption.Create(instance);
      _cardSetting = _user.CardSettings.Single(x => x.Id == _card.CardSettingId);
    } else {
      _instance = FSharpOption<Projection.ExampleInstance>.None;
    }
  }

  public override async Task SetParametersAsync(ParameterView parameters) {
    await base.SetParametersAsync(parameters);
    _user = await UserTask;
    await loadCards();
    if (_instance.IsSome()) {
      await ShowFront();
    }
    StateHasChanged();
  }

  protected override void OnAfterRender(bool firstRender) {
    isRendered = true;
  }

  async Task SaveScore(Score score) {
    var (timeInterval, intervalOrSteps, easeFactor) = Scheduler.Calculate(_card, _cardSetting, score);
    await DbExecutor.CommandAsync(db => SanitizeHistoryRepository.AddAndSaveAsync(db, _stack.Id, score, TimeProvider.utcNow, timeInterval, easeFactor, TimeProvider.utcNow - frontVisible, intervalOrSteps));
    // medTODO needs `undo review` support
    await loadCards();
    await ShowFront();
  }

  async Task FocusButton() =>
    await (
      isFront
      ? ShowAnswerButton
      : GoodButton
    ).Focus(Js);


  async Task ShowFront() {
    frontVisible = TimeProvider.utcNow;
    if (_instance.IsSome()) {
      isFront = true;
      iframeSrcdoc = _front;
      if (isRendered) {
        StateHasChanged();
        await ShowAnswerButton.Focus(Js);
      }
    }
    StateHasChanged();
  }

  async Task ShowBack() {
    isFront = false;
    iframeSrcdoc = _back;
    var (again, hard, good, easy) = Scheduler.Intervals(_card, _cardSetting);
    AgainInterval = again;
    HardInterval = hard;
    GoodInterval = good;
    EasyInterval = easy;
    if (isRendered) {
      await Task.Delay(50); // the Focus below needs this. lowTODO put focusElement in OnAfterRenderAsync
      await GoodButton.Focus(Js);
    }
  }

  async Task EnableBlindMode() {
    await Js.InvokeAsync<object>("Listen", DotNetObjectReference.Create(this));
    isBlindMode = true;
    await Speak(_frontSynth);
  }

  async Task Speak(string msg) =>
    await Js.InvokeAsync<object>("Speak", msg);

  async Task DisableBlindMode() {
    await Js.InvokeAsync<object>("StopListening", DotNetObjectReference.Create(this));
    isBlindMode = false;
  }

  [JSInvokable]
  public async Task<string> GetTranscript(string rawTranscript) {
    this.transcript = rawTranscript.Trim().ToLower();
    StateHasChanged();
    switch (this.transcript) {
      case "what":
        if (isFront == true) {
          await Speak(_frontSynth);
        } else {
          await Speak(_backSynth);
        }
        break;
      case "tell me":
        await ShowBack();
        await Speak(_backSynth);
        break;
      case "again":
        await SaveScore(Score.Again);
        await Speak(_frontSynth);
        break;
      case "hard":
        await SaveScore(Score.Hard);
        await Speak(_frontSynth);
        break;
      case "good":
        await SaveScore(Score.Good);
        await Speak(_frontSynth);
        break;
      case "easy":
        await SaveScore(Score.Easy);
        await Speak(_frontSynth);
        break;
      default:
        break;
    }
    return "C# received: " + this.transcript;
  }

  Task OnKeyDown(KeyboardEventArgs eventArgs) {
    if (isFront && (eventArgs.Key == "ArrowDown" || eventArgs.Key == "ArrowRight")) {
      return ShowBack();
    } else if (!isFront) {
      return eventArgs.Key switch {
        "0" => SaveScore(Score.Again),
        "1" => SaveScore(Score.Hard),
        "2" => SaveScore(Score.Good),
        "3" => SaveScore(Score.Easy),
        _ => Task.CompletedTask
      };
    }
    return Task.CompletedTask;
  }

}
